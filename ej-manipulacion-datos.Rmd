---
title: "Unidad 1 - Ejercicio - Manipulación de datos en R"
author: "Nidia"
date: "6/2/2021"
output:
  html_document:
    df_print: paged
---

```{css, echo=FALSE}
body {
  padding-bottom: 52px;
}
```

## Paquetes básicos de manipulación de datos

Comenzamos con las líneas habituales:

```{r message=FALSE, warning=FALSE}
rm(list = ls())
setwd('/home/yoki/Caicyt/Estilometria-con-R')

library(readr)
library(dplyr)
```


`readr` es un paquete que permite leer y escribir archivos. En el caso de los archivos tabulares, reconoce automáticamente el tipo de datos de cada columna (cadena de caracteres, entero, fecha, booleano, etc.). El paquete `dplyr` permite manipular tablas (seleccionar filas o columnas, filtrar, renombrar, combinar tablas, etc.). 

Los paquetes `readr` y `dplyr` son parte del núcleo de `tidyverse` (del inglés _tidy_--prolijo-- y _universe_) una colección de librerías concebidas para trabajar en conjunto de manera eficiente y coherente siguiendo una filosofía común. El concepto de _tidy data_ fue propuesto por Hadley Wickham en un [artículo de 2014](https://doi.org/10.18637/jss.v059.i10) para el _Journal of Statistical Software_.


## Leer archivos y seleccionar datos

Usamos la función `read_csv` para leer un archivo csv que contiene información sobre entidades reconocidas en _Relación de las cosas sucedidas en el Río de la Plata_ y guardamos el contenido en la variable `phernandez`. Usamos el comando `head(dataframe, cantidaddelineas)` para mostrar los valores de las primeras 20 líneas del archivo.

```{r  message=FALSE, warning=FALSE}
phernandez <- read_csv('PHernandez_RelCosas.csv')
head(phernandez, 20)
```

`head()` nos permite ver el encabezado de la tabla y los primeros registros. En la salida de `head()`, vemos que esta tabla contiene muchísima información. Para este ejercicio, vamos a seleccionar sólo las columnas que indican el nombre de las entidades reconocidas (`QUOTE_TRANSCRIPTION`), el tipo de entidad (`TYPE`), las etiquetas asociadas a cada entidad (`TAGS`) y los comentarios (`COMMENTS`). Para eso, vamos a pasarle los nombres de las columnas que queremos seleccionar a la función `select()`. `select()` también nos permite renombrar columnas escribiendo `nuevo nombre = nombre actual`. 

El flujo de los datos es el siguiente: el símbolo `%>%` (conocido como "pipe") envía el contenido de la variable `phernandez` a la función `select()`. `select()` selecciona las columnas indicadas entre paréntesis y el resultado de esta selección es enviado a la función `arrange()` que ordena los resultados alfabéticamente siguiendo como prioridad el orden de las columnas indicadas entre paréntesis. El resultado de esta operación es asignado a la variable `phernandez_seleccion`. Como habrás notado, en R se estila escribir una operación por línea.

```{r message=FALSE, warning=FALSE}
phernandez_seleccion <- 
  phernandez %>%
  select(ENTIDAD = QUOTE_TRANSCRIPTION, TYPE, TAGS, COMMENTS) %>%
  arrange(ENTIDAD, TYPE, TAGS)

phernandez_seleccion
```

En el chunk anterior podemos observar otra particularidad de R: basta con invocar una variable y ejecutar la porción de código correspondiente para poder ver el contenido de la variable en la consola. Así, podemos ver que la tabla `phernandez_seleccion` contiene muchas líneas duplicadas (pues se diferenciaban con valores de las columnas que ya no están). Para eliminar los registros duplicados, podemos usar la función `distinct`:

```{r}
nrow(phernandez)

phernandez_seleccion <- distinct(phernandez_seleccion)

nrow(phernandez_seleccion)
```
En el código precedente usamos `nrow()`, una función que devuelve el número de filas de un dataframe. Como podemos observar comparando la salida de `nrow()` antes y después de aplicar `distinct()`, el tamaño del dataframe se redujo a menos de la mitad.


## Agrupar por valores, filtrar por valor y eliminar columnas

A continuación, vamos a inspeccionar cuántas entidades hay para cada tipo. En otras palabras, queremos saber cuántos registros hay para cada uno de los diferentes valores de la columna `TYPE`. Para eso, le indicamos a la función `group_by()` que se base en la columna `TYPE` y redirigimos el resultado a `summarise()` y `n()` que producen el conteo.

```{r message=FALSE, warning=FALSE}
phernandez_seleccion %>%
  group_by(TYPE) %>%
  summarise(nro_entidades = n())
```

En nuestro dataframe predominan las entidades referidas a personas. Vamos a filtrar el dataset para conservar sólo las entidades de tipo 'PERSON' usando `filter()`. La columna `TYPE` ya no aporta información en el resultado (todas las líneas van a tener valor 'PERSON'), por lo que es mejor eliminarla. ¿Cómo borrar una columna de un dataframe? Muy sencillo, usamos `select()` con el nombre de la columna que queremos eliminar precedido de un signo `-`.

Guardamos en una nueva variable, `personajes`, el dataframe resultante de estas operaciones. 

```{r}
personajes <- 
  phernandez_seleccion %>%
  filter(TYPE == 'PERSON') %>%
  select(-TYPE)

personajes
```

Podemos observar que el dataframe 'personajes' tiene 200 registros. Esto coincide con el resultado del conteo realizado más arriba con `group_by()` y `summarise()`.

## Filtrar valores vacíos, extraer información y agregar columnas

Si observamos los valores de la columna `TAGS`, encontraremos que las entidades de nuestro dataset han sido categorizadas siguiendo un vocabulario controlado. También encontraremos que en algunos casos no han recibido ninguna categoría (cf. 'Estevan de Vallejos'), en ese caso, el valor de `TAGS` es `NA`, es decir _not available_ (no disponible).

Supongamos que nos interesa identificar personajes según su origen (pueblos originarios/invasores europeos) y según la facción (partidarios de Álvar Núñez y partidarios de Domingo de Irala) basándonos en la información de la columna `TAGS`. Vamos a crear una nueva variable `personajes_categ` en la que vamos a registrar esa información.

Primero eliminamos los personajes para los que no hay información (valor `NA` en `TAGS`) usando la función `drop_na()` de la librería `tidyr`. Luego, agregamos dos columnas nuevas `ORIGEN` y `FACCION`. En `ORIGEN` registraremos el valor 'indio' o 'conquistador' según el texto que encontremos para cada personaje en `TAGS`. En `FACCION` registraremos el valor 'iralista' o 'alvarista' de acuerdo a la información asignada a cada personaje en `TAGS`. Para esto, usamos una función de `stringr`, una librería de manipulación de cadenas de caracteres (o _strings_), llamada `str_extract()`. `str_extract()` permite extraer pequeños strings de strings más extensos. Tanto `stringr` como `tidyr` son parte de `tidyverse`. De ahora en adelante, en lugar de llamar a cada librería por separado, haremos `library(tidyverse)`.

Finalmente, volvemos a aplicar `distinct()` al resultado para eliminar filas duplicadas.

```{r}
library(stringr)
library(tidyr)

personajes_categ <-
  personajes %>%
  drop_na(TAGS) %>%
  mutate(
    ORIGEN = str_extract(TAGS, "indio|conquistador"),
    FACCION = str_extract(TAGS, "iralista|alvarista")
  ) %>%
  select(ENTIDAD, ORIGEN, FACCION) %>%
  distinct()

personajes_categ
```

Con esta tabla de categorizacion de los personajes, podemos hacer un conte básico de orígenes y bandos. Recurrimos nuevamente a `group_by` y `summarise`. 

```{r  message=FALSE, warning=FALSE}
personajes_categ %>%
  group_by(ORIGEN, FACCION) %>%
  summarise(nro_entidades = n())
```

## Generar gráficos

Es posible ilustrar fácilmente estos conteos con un gráficos de barras usando `ggplot2`. Vamos a mostrar el conteo pero sólo distinguiendo por ORIGEN. Primero guardamos la figura en una variable `personajes_categ` y la mostramos:

```{r}
library(ggplot2)

personajes_categ %>%
  ggplot() +
  aes(x = ORIGEN, fill = ORIGEN) +
  geom_bar()
```

Podemos guardar la última figura al disco con un nombre de archivo a elección.

```{r  message=FALSE, warning=FALSE}
ggsave("conteo_personajes_categ.png")
```


## Unir dataframes

Vamos a extender el primer dataset con el que trabajamos, las entidades de la relación de Pero Hernández, con los datos de un segundo texto, _Relación de un viaje al Río de la Plata_ de Acarette du Biscay. 

```{r  message=FALSE, warning=FALSE}
dubiscay <- read_csv("DuBiscay_RelDeUnViaje.csv")
dubiscay
```

Repetimos los tratamientos que realizamos anteriormente al dataframe `phernandez_seleccion`:

```{r}
dubiscay_seleccion <-
  dubiscay %>%
  rename(ENTIDAD = QUOTE_TRANSCRIPTION) %>%
  drop_na(TYPE) %>%
  select(ENTIDAD, TYPE, TAGS, COMMENTS) %>%
  distinct()

dubiscay_seleccion
```

Aquí, en lugar de renombrar la columna de entidades dentro del `select()` como hicimos anteriormente, lo hicimos en una línea diferente y usando la función `rename()`. 

Una vez armonizadas las estructuras de ambos dataframes, podemos unirlos para conservar las entidades de ambos textos en una sola variable que llamaremos `corpus_pelagios`. Pero antes, vamos a agregar una nueva columna llamada `FUENTE` con la información del documento fuente de cada entidad. Luego concatenamos los dataframes con `bind_rows()`.

```{r}
dubiscay_seleccion <-
  dubiscay_seleccion %>%
  mutate(FUENTE = "Du Biscay")

phernandez_seleccion <-
  phernandez_seleccion %>%
  mutate(FUENTE = "Pero Hernandez")

corpus_pelagios <- bind_rows(
  phernandez_seleccion,
  dubiscay_seleccion
)

corpus_pelagios
```

## Guardar CSV

Para guardar el dataframe que construimos en un nuevo archivo CSV, usamos la función `write_csv()` del siguiente modo:

```{r}
write_csv(corpus_pelagios, "entidades_corpus_pelagios.csv")
```

# Práctica

* Leer `DiazDeGuzman_ArgManus.csv` como dataframe.
* Seleccionar las columnas`QUOTE_TRANSCRIPTION`, `TYPE`, `COMMENTS`, `TAGS` y renombrar `QUOTE_TRANSCRIPTION` como `ENTIDAD`.
* Eliminar las filas que tienen `TYPE` vacío y las filas duplicadas.
* Asignar una nueva columna con el valor de `FUENTE` como "Diaz de Guzman". 
* Unir este dataframe de entidades al dataframe `corpus_pelagios`.
* Hacer un gráfico de barras con la cantidad de entidades que tiene el Corpus Pelagios por cada `FUENTE`.
* Finalmente, guardar el dataframe completo de `corpus_pelagios` en un archivo CSV de nombre "entidades_corpus_pelagios_2.csv".




```{r eval=FALSE, include=FALSE}
# Tarea resuelta por les profes
guzman <-
  read_csv("DiazDeGuzman_ArgManus.csv") %>%
  select(ENTIDAD = QUOTE_TRANSCRIPTION, TYPE, TAGS, COMMENTS) %>%
  drop_na(TYPE) %>%
  distinct() %>%
  mutate(FUENTE = "Diaz de Guzman")

corpus_pelagios_2 <-
  bind_rows(corpus_pelagios, guzman)

corpus_pelagios_2 %>%
  ggplot() +
  aes(x = FUENTE, fill = FUENTE) +
  geom_bar()
```

